trigger:
- latest

pool:
  vmImage: 'windows-latest'

variables:
  solution: '**/*.sln'
  buildPlatform: 'Any CPU'
  buildConfiguration: 'Debug'
  # Folder where pipeline artifacts (build outputs) are placed.
  pipelineFolder: '$(Build.SourcesDirectory)/PipelineOutput'
  # Set to 'true' to run tests.
  RunTests: 'false'
  # Email and user for git commit. Defaults to built-in variables if not provided.
  GitHubEmail: $(GitHubEmail)
  GitHubUser: $(GitHubUser)

steps:
- task: NuGetToolInstaller@1
  inputs:
    versionSpec: 
    checkLatest: true

- task: NuGetCommand@2
  inputs:
    restoreSolution: '$(solution)'

- task: VSBuild@1
  inputs:
    solution: '$(solution)'
    vsVersion: '17.0'
    platform: '$(buildPlatform)'
    configuration: '$(buildConfiguration)'
    maximumCpuCount: true
    msbuildArchitecture: 'x64'
    createLogFile: true
    logFileVerbosity: 'detailed'

# Run tests only if RunTests is true
- task: VSTest@2
  condition: eq(variables['RunTests'], 'true')
  inputs:
    platform: '$(buildPlatform)'
    configuration: '$(buildConfiguration)'

# Push NuGet package(s) to your Azure Artifacts feed
- task: NuGetCommand@2
  displayName: 'Push NuGet packages to Azure Artifacts'
  inputs:
    command: 'push'
    packagesToPush: '$(Build.ArtifactStagingDirectory)/**/*.nupkg;!$(Build.ArtifactStagingDirectory)/**/*.symbols.nupkg'
    nuGetFeedType: 'internal'
    publishVstsFeed: '4a801188-824e-4a83-b4e5-7fdcc78c6c71/05698a6e-affb-4164-b5f8-c68b8e1a2c92'
    allowPackageConflicts: true

# Publish build artifacts from the pipeline folder (separate from your provided artifact link)
- task: PublishBuildArtifacts@1
  inputs:
    PathtoPublish: '$(pipelineFolder)'
    ArtifactName: 'drop'

# Create a GitHub Release with the tag "Pre-release"
- task: GitHubRelease@1
  inputs:
    gitHubConnection: 'zombi-dev-org'
    repositoryName: '$(Build.Repository.Name)'
    action: 'create'
    target: '$(Build.SourceVersion)'
    tagSource: 'gitTag'
    title: 'Release $(Build.SourceVersion)'
    isPreRelease: true
    changeLogCompareToRelease: 'lastFullRelease'
    changeLogType: 'commitBased'
    assets: '$(Build.ArtifactStagingDirectory)/**/*'

- task: PublishPipelineArtifact@1
  inputs:
    targetPath: '$(Pipeline.Workspace)'
    artifact: '$(Build.SourceVersion) - $(Build.BuildId)'
    publishLocation: 'pipeline'

# Update README.md with dynamic build info using automatically retrieved email and user
- task: Bash@3
  displayName: 'Update README.md'
  inputs:
    targetType: 'inline'
    script: |
      echo "Updating README.md with dynamic build information..."
      
      # Retrieve pipeline variables for commit details
      COMMIT_ID=$(Build.SourceVersion)
      COMMIT_LINK="https://github.com/zombi-dev-org/Project-Multiground/commit/${COMMIT_ID}"
      ARTIFACT_LINK="https://github.com/zombi-dev-org/Project-Multiground/actions/runs/$(Build.BuildId)"
      RELEASE_LINK="https://github.com/zombi-dev-org/Project-Multiground/releases/tag/Pre-release"
      
      # Replace placeholders in the README.md file.
      sed -i "s|\[\[latest commit ID\]\]|${COMMIT_ID}|g" README.md
      sed -i "s|\[\[latest commit link\]\]|${COMMIT_LINK}|g" README.md
      sed -i "s|\[\[latest commit artifact's link\]\]|${ARTIFACT_LINK}|g" README.md
      sed -i "s|\[\[latest commit release link\]\]|${RELEASE_LINK}|g" README.md
      
      git checkout $(Build.SourceBranchName)
      
      # Use provided GitHub email and user if set; otherwise fall back to built-in variables.
      EMAIL="${GitHubEmail}"
      if [ -z "$EMAIL" ]; then
         EMAIL=$(Build.RequestedForEmail)
      fi
      USER="${GitHubUser}"
      if [ -z "$USER" ]; then
         USER=$(Build.RequestedFor)
      fi
      
      git config --global user.email "$EMAIL"
      git config --global user.name "$USER"
      
      git add README.md
      git commit -m "Update README.md for ${COMMIT_ID}"
      git push origin $(Build.SourceBranchName)
      
      echo "Finished!"
